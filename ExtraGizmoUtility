    public class ExtraGizmoUtility
    {
        public static void DrawCylinderGizmo(float height, float radius, Vector3 center, Vector3 forward, Vector3 up, bool showWireFrame = true, float degree = 360, int densitySample = 10)
        {
            Vector3 pointMaxHeight = (height / 2f) * up;

            GetCircleIteration(radius, degree, densitySample, out int rotIteration, out float percPerIteration);
            for (int i = 0; i <= rotIteration; i++)
            {
                float perc = (float)i * percPerIteration;

                Vector3 currentDistancePoint = GetAngleDirectionByPerc(perc, forward, up, degree) * radius;

                if (showWireFrame && height != 0)
                {
                    if (i % densitySample == 0 || i == rotIteration)
                    {
                        //height lines
                        Gizmos.DrawLine(center + pointMaxHeight + currentDistancePoint, center - pointMaxHeight + currentDistancePoint);
                    }
                }
            }

            //top circle
            DrawCircleGizmo(center + pointMaxHeight, radius, forward, up, showWireFrame, degree, densitySample);
            //bottom circle
            DrawCircleGizmo(center - pointMaxHeight, radius, forward, up, showWireFrame, degree, densitySample);
        }
        public static void DrawCircleGizmo(Vector3 center, float radius, Vector3 forward, Vector3 up, bool showWireFrame = true, float degree = 360, int densitySample = 10)
        {

            GetCircleIteration(radius, degree, densitySample, out int rotIteration, out float percPerIteration);
            for (int i = 0; i <= rotIteration; i++)
            {
                float perc = (float)i * percPerIteration;

                Vector3 currentDistancePoint = GetAngleDirectionByPerc(perc, forward, up, degree) * radius;
                Vector3 nextDistancePoint = GetAngleDirectionByPerc(perc + percPerIteration, forward, up, degree) * radius;

                //does not need to render the last iteration cause it would over shot
                if (i < rotIteration)
                {
                    //arc lines
                    Gizmos.DrawLine(center + currentDistancePoint, center + nextDistancePoint);
                }

                if (showWireFrame)
                {
                    if (i % densitySample == 0 || i == rotIteration)
                    {
                        //radius lines
                        Gizmos.DrawLine(center, center + currentDistancePoint);
                    }
                }

            }
        }

        /// <summary>
        /// provide iteration count for loop.
        /// </summary>
        /// <param name="densitySample">lower the number, the more it detailed the gizmo will be.</param>
        /// <param name="percPerIteration">percentage for a single iteration.</param>
        static void GetCircleIteration(float radius, float degree, int densitySample, out int iteration, out float percPerIteration)
        {
            iteration = (int)((radius / densitySample) * (degree / 360));
            //if (iteration < densitySample * 4) iteration = (int)(densitySample * 4); // min iteration

            percPerIteration = 1f / iteration;
        }

        static Vector3 GetAngleDirectionByPerc(float perc, Vector3 forward, Vector3 up, float degree = 360)
        {
            Quaternion rot = Quaternion.AngleAxis(perc * degree, up);
            return (rot * forward);
        }
    }
